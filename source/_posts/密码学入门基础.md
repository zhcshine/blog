---
title: 密码学入门基础
date: 2019-08-19 08:45:34
tags:
---
# 古典密码： 替换式密码或移项式密码

## 凯撒密码

> 凯撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移量是左移3的时候（解密时的密钥就是3）：

```shell
明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ
密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC
```

## 替换式密码缺点

暴力破解，密码本的安全性

# 现代密码学：Hash （散列函数）

> Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

> Hash算法可以将一个数据转换为一个标志，这个标志和源数据的每一个字节都有十分紧密的关系。Hash算法还具有一个特点，就是很难找到逆向规律。

> Hash算法是一个广义的算法，也可以认为是一种思想，使用Hash算法可以提高存储空间的利用率，可以提高数据的查询效率，也可以做数字签名来保障数据传递的安全性。所以Hash算法被广泛地应用在互联网应用中。

> Hash算法也被称为散列算法，Hash算法虽然被称为算法，但实际上它更像是一种思想。Hash算法没有一个固定的公式，只要符合散列思想的算法都可以被称为是Hash算法。

## MD5

## SHA

* SHA-1算法的哈希值大小为160位，其计算输出长度为40位。(SHA-1不再推荐使用)
* SHA-224算法的哈希值大小为224位，其计算输出长度为56位。
* SHA-256算法的哈希值大小为256位，其计算输出长度为64位。
* SHA-384算法的哈希值大小为384位，其计算输出长度为96位。
* SHA-512算法的哈希值大小为384位，其计算输出长度为128位。

# 现代密码学：对称加密

> 对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。

## DES

> 数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来

> DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。

> 1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个DES密钥。

>美国国家标准局倡导的AES即将作为新标准取代DES。

## AES

## 对称加密的缺点

甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。

# 现代密码学：非对称加密

> 公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的

## RSA

# RSA算法

> 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。 RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。

RSA算法运用的几个数论知识： 互素关系， 欧拉函数， 欧拉定理， 模逆元

## 互素关系

如果没有大于1的正数既是r的因数也是s的因数，则r和s互素。

## 欧拉函数

在数论，对正整数m，欧拉函数φ(m)是小于或等于m的正整数中与m互素的数的数目

1. 如果m是素数， φ(m)=m-1, 例如φ(3) = 2
2. 若m = p * q, φ(m) = (p-1) * (q-1)

## 欧拉定理

在数论中，欧拉定理是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互素，则a^φ(n)≡1 (mod n)

## 模逆元

如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的"模反元素"。

## rsa公钥密钥生成方法

公钥，密钥生成方法

1. 随机取俩个不相等素数p, q; 例如：p=61, q=53  # 实际应用中，这两个质数很大，常常是几百位

2. 计算p和q的乘积n， 其中n的长度就是密钥的长度; n=p*q=3233 3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位  # 实际应用中，RSA密钥一般是1024位，重要场合则为2048位

3. 计算n的欧拉函数φ(n); φ(n) = (p-1)(q-1) = 60*52 = 3120

4. 随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质; e = 17 

5. 计算e对于φ(n)的模逆元d 

    1. ed ≡ 1 (mod φ(n))                # 模逆元公式A
    
    2. ed - 1 = kφ(n)                   # 模逆元公式转换B
    
    3. ed - kφ(n) = 1                   # 转换公式
    
    4. ex + φ(n)y = 1                   # 转换公式 (e=17, φ(n)=3120, x=d, y=-k)  
    
    5. 17x + 3120y = 1                  # 代入数值

6. 扩展欧几里得算法求解17x+3120y=1， 一组整数解为 (x,y)=(2753,-15)， 此时计算出d=2753

7. n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）

是否可以破解密钥？

1. 已知公钥(n, e)

2. 已知 ed ≡ 1 (mod φ(n))。只有知道e和φ(n)，才能算出d, 目前只需要算出φ(n)

3. 已知 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)，目前需要算出p和q

4. 已知 n=pq。只有将n因数分解，才能算出p和q，n已知，如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。

5. 可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。

6. 维基百科这样写道：

　　"对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。"

## rsa加密和解密
    
加密公钥 (n,e)

```shell
m^e ≡ c (mod n)  # m是明文， 必须是整数（字符串可以取ascii值或unicode值），且m必须小于n
65^17 ≡ c (mod 3233)  # 本例中n=3233，e=17
c = 2790  # 计算出c=2790, c则是密文
```

解密私钥(n,d)

```shell
c^d ≡ m (mod n)  # 公式一定成立，下面有介绍
2790^2753 ≡ m (mod 3233)  # 本例中c=2790, d=2753
m = 65  # 计算出明文m=65
```
## rsa私钥解密证明

1. c^d ≡ m (mod n)  # 要证明的公式A

2. 因为 m^e ≡ c (mod n)， 根据模运算的含义，所以 c = m^e - kn

3. 将c代入公式A中， (m^e - kn)^d ≡ m (mod n)

4. 将上述方程式的左侧用二项式定理展开，会发现都是n的倍数，模运算为0，所以可以简化为 m^e^d ≡ m (mod n) 即 m^(ed) = m (mod n)

5. 因为ed ≡ 1 (modφ(n))， 所以ed = 1 + hφ(n)

6. 代入公式B中 m^(1 + hφ(n)) ≡ m (mod n)  # 公式C

7. 当m与n互素时
     
    1. 根据欧拉定理m^φ(n) ≡ 1 (mod n) 可得m^φ(n) = kn + 1
    
    2. 上述公式两边乘以m得到 m * m^φ(n) = m * (kn + 1)
    
    3. 上述公式转换 m^(1 + hφ(n)) = m * (kn + 1) = m + mk * n ≡ m (mod n), 公式C得到证明
    
8. 当m与n不互素

    1. 由于n等于质数p和q的乘积，所以m必然等于kp或kq。
    
    2. 以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立： (kp)^(q-1) ≡ 1 (mod q)
    
    3. 进一步扩展，可得 [(kp)^(q-1)]^(h(p-1)) × kp ≡ kp (mod q)
    
    4. 根据上述可得 (kp)^(ed) ≡ kp (mod q)
    
    5. 根据上述可得 (kp)^(ed) = kp + tq
    
    6. 显然，t能被p整除， 即t=t’p,可以得出 (kp)^(ed) = kp+t′pq
    
    7. 因为m=kp, n=pq, 最后得出 m^(ed) ≡ m (mod n) 公式得证
   
# 补充：模算数

## 同余

### 同余表达式

维基百科

> 数学上，同余（英语：congruence modulo，符号：≡）是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。最先引用同余的概念与“≡”符号者为德国数学家高斯。

两个整数a， b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作

```markdown
a ≡ b (mod m)
```

### 同余换代

> 在任意一个成立的模同余式中，将任意子表达式替换为一个与其同余的子表达式，所得的模同余式依然成立

```markdown
(12 + 4) * 2 ≡ x + 1 (mod 7)
```

(12 + 4)(模7)同余与2，故上同余式可表示为

```markdown
2 * 2  ≡ x + 1 (mod 7)
```

### 代表元

> 每个整数恰好和整数0,1,2,...,m-1中的一个模m同余

例如，在模7的情况下，每个整数和整数0,1,2,3,4,5，6中的一个同余

### 商和余数

b被m除时，r为余数，q为商

```markdown
b = mq + r
```

余数操作运算符一般使用rem表示，例如25 rem 7 = 4

```markdown
如果a rem m = b rem m, 则 a ≡ b (mod m)
如果 a ≡ b (mod m)， 则a rem m = b rem m
```


### 用rem运算简化模同余数

例

```markdown
12 * 11 * 10 * 9 * 8 * 7 ≡ x (mod 13)
因为
12 * 11 = 132
132 rem 13 = 2
根据同余换代，上式可表示为
2 * 10 * 9 * 8 * 7 ≡ x (mod 13)
同上，上式可表示为
7 * 9 * 8 * 7 ≡ x (mod 13)
11 * 8 * 7 ≡ x (mod 13)
10 * 7 ≡ x (mod 13)
5 ≡ x (mod 13)
```

现在要求计算 12 * 11 * 10 * 9 * 8 * 7 * 6 rem 13

上面求出
```markdown
12 * 11 * 10 * 9 * 8 * 7 ≡ 5 (mod 13)
```

根据商和余数与模的关系

```markdown
如果 a ≡ b (mod m)， 则a rem m = b rem m
```

```markdown
12 * 11 * 10 * 9 * 8 * 7 * 6 rem 13 可转为 5 * 6 rem 13
```